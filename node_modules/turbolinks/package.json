{
  "name": "turbolinks",
  "version": "3.0.0",
  "description": "Turbolinks makes following links in your web application faster (use with Rails Asset Pipeline)",
  "main": "lib/assets/javascripts/turbolinks.js.coffee",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/ssorallen/turbolinks.git"
  },
  "keywords": [
    "turbolinks"
  ],
  "author": "",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/ssorallen/turbolinks/issues"
  },
  "homepage": "https://github.com/ssorallen/turbolinks",
  "gitHead": "a853a5fa02b799a4a529dbf90c7786ad7611b91a",
  "readme": "Turbolinks\n===========\n[![Build Status](https://travis-ci.org/rails/turbolinks.svg?branch=master)](https://travis-ci.org/rails/turbolinks)\n\nTurbolinks makes following links in your web application faster. Instead of letting the browser recompile the JavaScript and CSS between each page change, it keeps the current page instance alive and replaces only the body (or parts of) and the title in the head. Think CGI vs persistent process.\n\nThis is similar to [pjax](https://github.com/defunkt/jquery-pjax), but instead of worrying about what element on the page to replace and tailoring the server-side response to fit, we replace the entire body by default, and let you specify which elements to replace on an opt-in basis. This means that you get the bulk of the speed benefits from pjax (no recompiling of the JavaScript or CSS) without having to tailor the server-side response. It just works.\n\nDo note that this of course means that you'll have a long-running, persistent session with maintained state. That's what's making it so fast. But it also means that you may have to pay additional care not to leak memory or otherwise bloat that long-running state. That should rarely be a problem unless you're doing something really funky, but you do have to be aware of it. Your memory leaking sins will not be swept away automatically by the cleansing page change any more.\n\n\nHow much faster is it really?\n-----------------------------\n\nIt depends. The more CSS and JavaScript you have, the bigger the benefit of not throwing away the browser instance and recompiling all of it for every page. Just like a CGI script that says \"hello world\" will be fast, but a CGI script loading Rails on every request will not.\n\nIn any case, the benefit can be up to [twice as fast](https://github.com/steveklabnik/turbolinks_test/tree/all_the_assets) in apps with lots of JS and CSS. Of course, your mileage may vary, be dependent on your browser version, the moon cycle, and all other factors affecting performance testing. But at least it's a yardstick.\n\nThe best way to find out just how fast it is? Try it on your own application. It hardly takes any effort at all.\n\n\nNo jQuery or any other library\n--------------------------------\n\nTurbolinks is designed to be as light-weight as possible (so you won't think twice about using it even for mobile stuff). It does not require jQuery or any other library to work. But it works great _with_ the jQuery or Prototype framework, or whatever else you have.\n\n\nEvents\n------\n\nWith Turbolinks pages will change without a full reload, so you can't rely on `DOMContentLoaded` or `jQuery.ready()` to trigger your code. Instead Turbolinks fires events on `document` to provide hooks into the lifecycle of the page.\n\n***Load* a fresh version of a page from the server:**\n* `page:before-change` a Turbolinks-enabled link has been clicked *(see below for more details)*\n* `page:fetch` starting to fetch a new target page\n* `page:receive` the page has been fetched from the server, but not yet parsed\n* `page:before-unload` the page has been parsed and is about to be changed\n* `page:change` the page has been changed to the new version (and on DOMContentLoaded)\n* `page:update` is triggered alongside both page:change and jQuery's ajaxSuccess (if jQuery is available - otherwise you can manually trigger it when calling XMLHttpRequest in your own code)\n* `page:load` is fired at the end of the loading process.\n\nHandlers bound to the `page:before-change` event may return `false`, which will cancel the Turbolinks process.\n\nBy default, Turbolinks caches 10 of these page loads. It listens to the [popstate](https://developer.mozilla.org/en-US/docs/DOM/Manipulating_the_browser_history#The_popstate_event) event and attempts to restore page state from the cache when it's triggered. When `popstate` is fired the following process happens:\n\n***Restore* a cached page from the client-side cache:**\n* `page:before-unload` page has been fetched from the cache and is about to be changed\n* `page:change` page has changed to the cached page.\n* `page:restore` is fired at the end of restore process.\n\nThe number of pages Turbolinks caches can be configured to suit your application's needs:\n\n```javascript\n// View the current cache size\nTurbolinks.pagesCached();\n\n// Set the cache size\nTurbolinks.pagesCached(20);\n```\n\nIf you need to make dynamic HTML updates in the current page and want it to be cached properly you can call:\n```javascript\nTurbolinks.cacheCurrentPage();\n```\n\nWhen a page is removed from the cache due to the cache reaching its size limit, the `page:expire` event is triggered.  Listeners bound to this event can access the cached page object using `event.originalEvent.data`.  Keys of note for this page cache object include `url`, `body`, and `title`.\n\nTo implement a client-side spinner, you could listen for `page:fetch` to start it and `page:receive` to stop it.\n\n```javascript\n// using jQuery for simplicity\n\n$(document).on(\"page:fetch\", startSpinner);\n$(document).on(\"page:receive\", stopSpinner);\n```\n\nDOM transformations that are idempotent are best. If you have transformations that are not, bind them to `page:load` (in addition to the initial page load) instead of `page:change` (as that would run them again on the cached pages):\n\n```javascript\n// using jQuery for simplicity\n\n$(document).on(\"ready page:load\", nonIdempotentFunction);\n```\n\nTransition Cache: A Speed Boost\n-------------------------------\n\nTransition Cache, added in v2.2.0, makes loading cached pages instantaneous. Once a user has visited a page, returning later to the page results in an instant load.\n\nFor example, if Page A is already cached by Turbolinks and you are on Page B, clicking a link to Page A will *immediately* display the cached copy of Page A. Turbolinks will then fetch Page A from the server and replace the cached page once the new copy is returned.\n\nTo enable Transition Cache, include the following in your javascript:\n```javascript\nTurbolinks.enableTransitionCache();\n```\n\nThe one drawback is that dramatic differences in appearance between a cached copy and new copy may lead to a jarring affect for the end-user. This will be especially true for pages that have many moving parts (expandable sections, sortable tables, infinite scrolling, etc.).\n\nIf you find that a page is causing problems, you can have Turbolinks skip displaying the cached copy by adding `data-no-transition-cache` to any DOM element on the offending page.\n\nProgress Bar\n------------\n\nBecause Turbolinks skips the traditional full page reload, browsers won't display their native progress bar when changing pages. To fill this void, Turbolinks offers an optional JavaScript-and-CSS-based progress bar to display page loading progress.\n\nAs of Turbolinks 3.0, the progress bar is turned on by default.\n\nTo disable (or re-enable) the progress bar, include one of the following in your JavaScript:\n\n```javascript\nTurbolinks.ProgressBar.disable();\nTurbolinks.ProgressBar.enable();\n```\n\nThe progress bar is implemented on the `<html>` element's pseudo `:before` element and can be **customized** by including CSS with higher specificity than the included styles. For example:\n\n```css\nhtml.turbolinks-progress-bar::before {\n  background-color: red !important;\n  height: 5px !important;\n}\n```\n\nControl the progress bar manually using these methods:\n\n```javascript\nTurbolinks.ProgressBar.start();\nTurbolinks.ProgressBar.advanceTo(value); // where value is between 0-100\nTurbolinks.ProgressBar.done();\n```\n\nInitialization\n--------------\n\nTurbolinks will be enabled **only** if the server has rendered a `GET` request.\n\nSome examples, given a standard RESTful resource:\n\n* `POST :create` => resource successfully created => redirect to `GET :show`\n  * Turbolinks **ENABLED**\n* `POST :create` => resource creation failed => render `:new`\n  * Turbolinks **DISABLED**\n\n**Why not all request types?** Some browsers track the request method of each page load, but triggering pushState methods don't change this value.  This could lead to the situation where pressing the browser's reload button on a page that was fetched with Turbolinks would attempt a `POST` (or something other than `GET`) because the last full page load used that method.\n\n\nOpting out of Turbolinks\n------------------------\n\nBy default, all internal HTML links will be funneled through Turbolinks, but you can opt out by marking links or their parent container with `data-no-turbolink`. For example, if you mark a div with `data-no-turbolink`, then all links inside of that div will be treated as regular links. If you mark the body, every link on that entire page will be treated as regular links.\n\n```html\n<a href=\"/\">Home (via Turbolinks)</a>\n<div id=\"some-div\" data-no-turbolink>\n  <a href=\"/\">Home (without Turbolinks)</a>\n</div>\n```\n\nNote that internal links to files containing a file extension other than **.html** will automatically be opted out of Turbolinks. So links to /images/panda.gif will just work as expected.  To whitelist additional file extensions to be processed by Turbolinks, use `Turbolinks.allowLinkExtensions()`.\n\n```javascript\nTurbolinks.allowLinkExtensions();                 // => ['html']\nTurbolinks.allowLinkExtensions('md');             // => ['html', 'md']\nTurbolinks.allowLinkExtensions('coffee', 'scss'); // => ['html', 'md', 'coffee', 'scss']\n```\n\nAlso, Turbolinks is installed as the last click handler for links. So if you install another handler that calls event.preventDefault(), Turbolinks will not run. This ensures that you can safely use Turbolinks with stuff like `data-method`, `data-remote`, or `data-confirm` from Rails.\n\nNote: in Turbolinks 3.0, the default behavior of `redirect_to` is to redirect via Turbolinks (`Turbolinks.visit` response) for XHR + non-GET requests. You can opt-out of this behavior by passing `turbolinks: false` to `redirect_to`.\n\n\njquery.turbolinks\n-----------------\n\nIf you have a lot of existing JavaScript that binds elements on jQuery.ready(), you can pull the [jquery.turbolinks](https://github.com/kossnocorp/jquery.turbolinks) library into your project that will trigger ready() when Turbolinks triggers the `page:load` event. It may restore functionality of some libraries.\n\nAdd the gem to your project, then add the following line to your JavaScript manifest file, after `jquery.js` but before `turbolinks.js`:\n\n``` js\n//= require jquery.turbolinks\n```\n\nAdditional details and configuration options can be found in the [jquery.turbolinks README](https://github.com/kossnocorp/jquery.turbolinks/blob/master/README.md).\n\nAsset change detection\n----------------------\n\nYou can track certain assets, like application.js and application.css, that you want to ensure are always of the latest version inside a Turbolinks session. This is done by marking those asset links with data-turbolinks-track, like so:\n\n```html\n<link href=\"/assets/application-9bd64a86adb3cd9ab3b16e9dca67a33a.css\" rel=\"stylesheet\"\n      type=\"text/css\" data-turbolinks-track>\n```\n\nIf those assets change URLs (embed an md5 stamp to ensure this), the page will do a full reload instead of going through Turbolinks. This ensures that all Turbolinks sessions will always be running off your latest JavaScript and CSS.\n\nWhen this happens, you'll technically be requesting the same page twice. Once through Turbolinks to detect that the assets changed, and then again when we do a full redirect to that page.\n\n\nEvaluating script tags\n----------------------\n\nTurbolinks will evaluate any script tags in pages it visits, if those tags do not have a type or if the type is text/javascript. All other script tags will be ignored.\n\nAs a rule of thumb when switching to Turbolinks, move all of your javascript tags inside the `head` and then work backwards, only moving javascript code back to the body if absolutely necessary. If you have any script tags in the body you do not want to be re-evaluated then you can set the `data-turbolinks-eval` attribute to `false`:\n\n```html\n<script type=\"text/javascript\" data-turbolinks-eval=false>\n  console.log(\"I'm only run once on the initial page load\");\n</script>\n```\n\nTriggering a Turbolinks visit manually\n---------------------------------------\n\nYou can use `Turbolinks.visit(path)` to go to a URL through Turbolinks.\n\nYou can also use `redirect_to path, turbolinks: true` in Rails to perform a redirect via Turbolinks.\n\nPartial replacements with Turbolinks (3.0+)\n-------------------------------------------\n\nYou can use either `Turbolinks.visit(path, options)` or `Turbolinks.replace(html, options)` to trigger partial replacement of nodes in your DOM instead of replacing the entire `body`.\n\nTurbolinks' partial replacement strategy relies on `id` attributes specified on individual nodes or a combination of `id` and `data-turbolinks-permanent` or `data-turbolinks-temporary` attributes.\n\n```html\n<div id=\"comments\"></div>\n<div id=\"nav\" data-turbolinks-permanent></div>\n<div id=\"footer\" data-turbolinks-temporary></div>\n```\n\nAny node with an `id` attribute can be partially replaced. If the `id` contains a colon, the key before the colon can also be targeted to replace many nodes with a similar prefix.\n\n```html\n<div id=\"comments\"></div>\n<div id=\"comments:123\"></div>\n```\n\n`Turbolinks.visit` should be used when you want to perform an XHR request to fetch the latest content from the server and replace all or some of the nodes.\n\n`Turbolinks.replace` should be used when you already have a response body and want to replace the contents of the current page with it. This is needed for contextual responses like validation errors after a failed `create` attempt since fetching the page again would lose the validation errors.\n\n```html+erb\n<body>\n  <div id=\"sidebar\" data-turbolinks-permanent>\n    Sidebar, never changes after initial load.\n  </div>\n\n  <div id=\"flash\" data-turbolinks-temporary>\n    You have <%= @comments.count %> comments.\n  </div>\n\n  <section id=\"comments\">\n    <%= @comments.each do |comment| %>\n      <article id=\"comments:<%= comment.id %>\">\n        <h1><%= comment.author %></h1>\n        <p><%= comment.body %></p>\n      </article>\n    <% end %>\n  </section>\n\n  <%= form_for Comment.new, remote: true, id: 'new_comment' do |form| %>\n    <%= form.text_area :content %>\n    <%= form.submit %>\n  <% end %>\n</body>\n\n<script>\n// Will change #flash, #comments, #comments:123\nTurbolinks.visit(url, change: 'comments')\n\n// Will change #flash, #comment_123\nTurbolinks.visit(url, change: 'comments:123')\n\n// Will only keep #sidebar\nTurbolinks.visit(url)\n\n// Will only keep #sidebar, #flash\nTurbolinks.visit(url, keep: 'flash')\n\n// Will keep nothing\nTurbolinks.visit(url, flush: true)\n\n// Same as visit() but takes a string or Document, allowing you to\n// do inline responses instead of issuing a new GET with Turbolinks.visit.\n// This is useful for things like form validation errors or other\n// contextualized responses.\nTurbolinks.replace(html, options)\n</script>\n```\n\nPartial replacement decisions can also be made server-side by using `redirect_to` or `render` with `change`, `keep`, or `flush` options.\n\n```ruby\nclass CommentsController < ActionController::Base\n  def create\n    @comment = Comment.new(comment_params)\n\n    if @comment.save\n      # This will change #flash, #comments\n      redirect_to comments_url, change: 'comments'\n      # => Turbolinks.visit('/comments', change: 'comments')\n    else\n      # Validation failure\n      render :new, change: :new_comment\n      # => Turbolinks.replace('<%=j render :new %>', change: 'new_comment')\n    end\n  end\nend\n```\n\n```ruby\n# Redirect via Turbolinks when the request is XHR and not GET.\n# Will refresh any `data-turbolinks-temporary` nodes.\nredirect_to path\n\n# Force a redirect via Turbolinks.\nredirect_to path, turbolinks: true\n\n# Force a normal redirection.\nredirect_to path, turbolinks: false\n\n# Partially replace any `data-turbolinks-temporary` nodes and nodes with `id`s matching `comments` or `comments:*`.\nredirect_to path, change: 'comments'\n\n# Partially replace any `data-turbolinks-temoprary` nodes and nodes with `id` not matching `something` and `something:*`.\nredirect_to path, keep: 'something'\n\n# Replace the entire `body` of the document, including `data-turbolinks-permanent` nodes.\nredirect_to path, flush: true\n```\n\n```ruby\n # Render with Turbolinks when the request is XHR and not GET.\n # Refresh any `data-turbolinks-temporary` nodes and nodes with `id` matching `new_comment`.\nrender view, change: 'new_comment'\n\n# Refresh any `data-turbolinks-temporary` nodes and nodes with `id` not matching `something` and `something:*`.\nrender view, keep: 'something'\n\n# Replace the entire `body` of the document, including `data-turbolinks-permanent` nodes.\nrender view, flush: true\n\n# Force a render with Turbolinks.\nrender view, turbolinks: true\n\n# Force a normal render.\nrender view, turbolinks: false\n```\n\nXHR Request Caching (3.0+)\n--------------------------\n\nTo prevent browsers from caching Turbolinks requests:\n\n```coffeescript\n# Globally\nTurbolinks.disableRequestCaching()\n\n# Per Request\nTurbolinks.visit url, cacheRequest: false\n```\n\nThis works just like `jQuery.ajax(url, cache: false)`, appending `\"_#{timestamp}\"` to the GET parameters.\n\nFull speed for pushState browsers, graceful fallback for everything else\n------------------------------------------------------------------------\n\nLike pjax, this naturally only works with browsers capable of pushState. But of course we fall back gracefully to full page reloads for browsers that do not support it.\n\n\nCompatibility\n-------------\n\nTurbolinks is designed to work with any browser that fully supports pushState and all the related APIs. This includes Safari 6.0+ (but not Safari 5.1.x!), IE10, and latest Chromes and Firefoxes.\n\nDo note that existing JavaScript libraries may not all be compatible with Turbolinks out of the box due to the change in instantiation cycle. You might very well have to modify them to work with Turbolinks' new set of events.  For help with this, check out the [Turbolinks Compatibility](http://reed.github.io/turbolinks-compatibility) project.\n\nTurbolinks works with Rails 3.2 and newer.\n\n\nInstallation\n------------\n\n1. Add `gem 'turbolinks'` to your Gemfile.\n1. Run `bundle install`.\n1. Add `//= require turbolinks` to your Javascript manifest file (usually found at `app/assets/javascripts/application.js`). If your manifest requires both turbolinks and jQuery, make sure turbolinks is listed *after* jQuery.\n1. Restart your server and you're now using turbolinks!\n\nRunning the tests\n-----------------\n\nRuby:\n\n```\nrake test:all\n\nBUNDLE_GEMFILE=Gemfile.rails42 bundle\nBUNDLE_GEMFILE=Gemfile.rails42 rake test\n```\n\nJavaScript:\n\n```\nnpm install\ncd test\nbundle\nbundle exec rackup\nopen http://localhost:9292/javascript/index.html\n```\n\nLanguage Ports\n--------------\n\n*These projects are not affiliated with or endorsed by the Rails Turbolinks team.*\n\n* [Flask Turbolinks](https://github.com/lepture/flask-turbolinks) (Python Flask)\n* [Django Turbolinks](https://github.com/dgladkov/django-turbolinks) (Python Django)\n* [ASP.NET MVC Turbolinks](https://github.com/kazimanzurrashid/aspnetmvcturbolinks)\n* [PHP Turbolinks Component](https://github.com/helthe/Turbolinks) (Symfony Component)\n* [PHP Turbolinks Package](https://github.com/frenzyapp/turbolinks) (Laravel Package)\n* [Grails Turbolinks](http://grails.org/plugin/turbolinks) (Grails Plugin)\n\nCredits\n-------\n\nThanks to Chris Wanstrath for his original work on Pjax. Thanks to Sam Stephenson and Josh Peek for their additional work on Pjax and Stacker and their help with getting Turbolinks released. Thanks to David Estes and Nick Reed for handling the lion's share of post-release issues and feature requests. And thanks to everyone else who's fixed or reported an issue!\n",
  "readmeFilename": "README.md",
  "_id": "turbolinks@3.0.0",
  "_shasum": "16516346a1030d347c8b7a1c82b4f997dae97e7a",
  "_from": "git://github.com/ssorallen/turbolinks.git",
  "_resolved": "git://github.com/ssorallen/turbolinks.git#a853a5fa02b799a4a529dbf90c7786ad7611b91a",
  "_fromGithub": true
}
